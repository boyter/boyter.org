<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Golang-Syd 25th May 2023</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Building a code search index in Go</h1>
				</section>

				<section>
					<h2>Who are you?</h2>
					<p>
					"Officially" technical lead/principle at Kablamo but a "code monkey" at heart.</p>
					<p>I blog <a href="https://boyter.org/">boyter.org</a> I free software <a href="https://github/boyter/">github/boyter/</a> I run <a href="https://searchcode.com/">searchcode.com</a> also on the twitter <a href="https://twitter.com/boyter">@boyter</a> activitypub <a href="https://honk.boyter.org/boyter">@boyter@honk.boyter.org</a></p>
				</section>


				<section>
					<h2>searchcode.com</h2>
					<p>IMAGE_HERE</p>
					<aside class="notes">So I run searchcode.com, and its iteration over the last 10 years has been from PHP to Python almost to Java and finally to Go.

The whole time that has happened one thing has been constant, which was the use of the index engine, which was provided using Sphinx Search and then a forked version called Manticore.

This made me feel like a bit of a fraud, how can I claim to be a search guy without using my own index. So after the first covid lockdown in 2020, I was hiking with a mate I decided I would build my own index.

Searchcode itself indexes about 75 billion lines of code across 40 million projects pulled from github, gitlab, bitbucket, codeberg, sr.ht and such. Thats about 120 million documents although it rises and falls.

It handles about 22 RPS mostly through the api, with some portion of those being search queries and the remainder being code view queries, although it does burst much higher from time to time. It works out being about 2.6 million requests a day.</aside>
				</section>

				<section>
					<h2>Requirements</h2>
					<ul>
						<li>Special characters <code>(i++)</code></li>
						<li>Inline searches find <code>i++</code> in <code>for(i:=0;i<100;i++)</code></li>
						<li>Site is free...</li>
						<li>Embed into application must use Go</li>
						<li>Entirely in RAM</li>
						<li>Needs a cool name. Caisson!</li>
						<li>Needs to be fun to work on!!!</li>
					</ul>
					<aside class="notes">So what were my requirements to build an index. This is important becauwse we can make design trade off decisions here

Im searching source code. This impacts the design!
 - special characters
 - inline searches find i++ in for(i:=0;i<100;i++)
 - no special search types (other than exact match)
Its a free website.
I want to embed into the application. So use Go!
Store everything in RAM cos ram is cheap!
We have TB's of code that we need to index...
$$$ save money... cos I am cheap
Want a single binary to deploy
Needs a cool name. Caisson. Named after the watertight structure used for digging foundations underwater. They are designed to workunder pressure. Hence the name.</aside>
				</section>

				<section>
					<h2>Search Lifecycle</h2>
					<img src="./img/index.png" style="border: none;" />
					<aside class="notes">
So what is an index?
In short, its something you feed in queries, and get back matching unique id's in some sort of order.
There are a lot of bits that go into a search engine, crawlers, indexers, the index, query parsers, 
data storage, etc... but its the index thats considered the "cool" thing to work on.

So here is a brief diagram of the stuff that goes into a search engine, and the index is the tiny bit in the middle... If I had more time id walk you though all of this because there are interesting problems for literally every part you see here, but lets just focus on the index itself.</aside>
				</section>

				<section>
					<h2>Why Go?</h2>
					<ul>
						<li>Reasonable performance</li>
						<li>Low memory usage</li>
						<li>Integer types int8, uint8, uint16, int32 etc...</li>
					</ul>
					<aside class="notes">So why Go? Most indexes are in C/C++/Rust 
					
Its actually by accident. I happened to write a tool to learn Go called scc, which counts programming code. Also there were decent syntax highlighters you can embed into your application such as chroma which, and I wanted both of those things without having to reimplement my own in Java...

But it turned out that Go was a pretty decent choice for this.

 - Reasonable performance (almost as fast as java)
 - Memory usage (this becomes important later!)
 - Decent libraries
 - Support for multiple integer types (memory savings!)


And as mentioned I wanted to run everything in a single binary, because it lowers latency and I wanted as simple a deployment as possible.

It also turns out that Go fits well with how I think about things. Looking back on this I don't think I would have been able to build it as well as I had in Java or any other language im familar with.
					</aside>
				</section>


				<section>
					<h2>Searching code</h2>
					<p>Trigrams</p>
<pre><code style="font-size: 18px; line-height: 1em;">searchcode ->	sea
		ear
		arc
		rch
		chc
		hco
		cod
		ode
</code></pre>
					<aside class="notes">So code search is in some ways easier than text, because you don't need to try to understand language in the way that you do when dealing with english, japanese or russian.

You do this by indexing on whats known as trigrams, where you break the text apart into characters of 3 and index those. You can actually use any number you want for ngrams, but trigrams work best when indexing source code.

One catch with this is that you get false positives, some inputs generate the same ngrams despite being different. You also have terms with low cardinality such as repeated works in a line. So the letter p 100 times is no more useful than 3 of them.

Another issueis that you get really large posting lists... what are posting lists? Well lets have a look at how to build an index
					</aside>
				</section>

				<section>
					<h2>How to build an index</h2>
					<p>Inverted index. Most common way to do it.</p>
<pre><code style="font-size: 14px; line-height: 1em;">map[string][]struct{}
map[string][]int64{} 
</code></pre>
					<ul>
						<li>Posting lists</li>
						<li>Need to implement skip lists or compression on the posting lists at scale</li>
 						<li>Supports a positional index</li>
					</ul>

					<aside class="notes">
					Quickly a positional index is one that stores where the term was found in the document. In theory you can then use the index to reconstruct the document entirely. One catch with this is that your index becomes larger than the thing you are indexing.
					Not fun to implement... so many details
					</aside>
				</section>

				<section>
					<h2>Trie</h2>
					<p>Typesense uses this, its also written in C++</p>
<img src="./img/trie.png" height="100px" style="border: none;" />
					<ul>
						<li>Big problem is not friendly to GC due to the use of pointers (problem for Go)</li>
						<li>Need to implement skip lists or compression on the posting lists at scale</li>
 						<li>Supports a positional index</li>
					</ul>

					<aside class="notes">
					I tried this, and the GC non friendly problem caused it to have massive delays while walking the pointers. I could have possibly done off heap tricks but I wanted to stick to normal Go.
					So what about bitslice signatures?
					</aside>
				</section>

				<section>
					<h2>Bloom filter</h2>
<img src="./img/bloom_example.png" style="border: none;" />
					
					<aside class="notes">
					bitslice signatures are built on bloom filters. So whats a bloom filter?
					So what is a bloom filter?

In short a probablistic data structure, that you can use to test the existance of something. You add items, and can check if it was added. They never return false negatives, but they do occassionaly lie and report something being added when it was not.

So lets look at this example,

We have a 8 bit bloom filter, and hash two terms, golang and searchcode. Goland hashes to bit position 0 and searchcode to bit position 6. To add an item we do the hash, and then set the bit position to 1.

If I want to check if searchcode was added, I hash it again and probe the bit position. If set to 1 it means it was possibly added. If I want to check for the existance of awesome I could hash that and get the position 2 and if I probe that I can see it was never set so I know it was never added.

The lie part comes from the hash function, where it might hash to position 0. So if I was checking for the existance of "java" and it hashes to bit position 0 I would assume it was added. This is a false positive.

For hashing you can use any hash that returns an integer. FNV and FNVa work well for this being fast enough and providing enough distribution. Murmur3 is meant to be good but I found it slower.
					</aside>
				</section>

				<section>
					<section>
						<h2>Search</h2>
	<img src="./img/bloomfilter.png" style="border: none;" />
						<aside class="notes">
						</aside>
					</section>
					<section>
						<img src="./img/bloomfilter_1.png" style="border: none;" />
					</section>
					<section>
						<img src="./img/bloomfilter_2.png" style="border: none;" />
					</section>
					<section>
						<img src="./img/bloomfilter_3.png" style="border: none;" />
					</section>
					<section>
						<img src="./img/bloomfilter_4.png" style="border: none;" />
					</section>
					<section>
						<img src="./img/bloomfilter_match.png" style="border: none;" />
					</section>
				</section>




				<section>
									<h2>Optimise</h2>
<pre><code style="font-size: 14px; line-height: 1em;">
┌──────────────────┐    ┌───────────────────────────────────────────────────────────────────┐
│      bucket      │───▶│                                                                   │
└──────────────────┘    │ 0011100000000000000000000000000011010010000000000000010000111111  │
                        │ 0000100000000110001000000000000000000000001010001000001000000000  │
                        │ 0010000000000000000000000000000001010001111111110000010100111111  │
                        │ 0000100011010000000000000000000000000000001010001000000110000000  │
                        │ 1100011000000001111111010100100010000000000000010000000000100100  │
                        │ 0000000000000000000000000000000000000001111111110000000000000000  │
                        │ 1000011000100001111111010100000010000000000000010000000000100100  │
                        │ 0000000000000000000000000000000000000001111111110000000000000000  │
                        │ 0000000000000010000000000011000000001000000000000000000000001000  │
                        │ 1111111000000000000000000000001000010000010000000000000000011000  │
                        │ 1111111111111111000000000011000000000000000000100010000000000000  │
                        │ 1111111000000000000000000000001000010000010000010000000000001000  │
                        │ 0000000000000000000000000000000000111110000000000000000000000000  │
                        │ 0000000001100000110000001000000000000000000001000000101001000000  │
                        │ 0000000000000000000100000000000000111110000000000000110000010000  │
                        │ 0000000000100001110000001000000001000000000000000000101001111111  │
                        │                                                                   │
                        └───────────────────────────────────────────────────────────────────┘
</code></pre>
					<aside class="notes">The next step is to optimise this to not waste memory. In searchcode its done by packing 64 documents into a bloom filter block or bucket. 

So if a bloom filter had 16 bits, we keep 16 uint64's in a slice.

It would look like what you see. This ensures we are optimally using the space. Because we pack 64 documents into each bucket we end up using a single bit per location in the bloom filter.</aside>
				</section>

				<section>
					<h2>Deterministic Keys</h2>
<pre><code style="font-size: 14px; line-height: 1em;">
┌──────────────────┐   ┌──────────────────┐   ┌──────────────────┐
│     caisson      ├─┬▶│  shard 512       ├┬─▶│     bucket-1     │
└──────────────────┘ │ └──────────────────┘│  └──────────────────┘
                     │                     │                      
                     │                     │  ┌──────────────────┐
                     │                     ├─▶│     bucket-2     │
                     │                     │  └──────────────────┘
                     │                     │                      
                     │                     │  ┌──────────────────┐
                     │                     └─▶│     bucket-3     │
                     │                        └──────────────────┘
                     │                                            
                     │                                            
                     │ ┌──────────────────┐   ┌──────────────────┐
                     └▶│  shard 2048      ├┬─▶│     bucket-1     │
                       └──────────────────┘│  └──────────────────┘
                                           │                      
                                           │  ┌──────────────────┐
                                           ├─▶│     bucket-2     │
                                           │  └──────────────────┘
                                           │                      
                                           │  ┌──────────────────┐
                                           └─▶│     bucket-3     │
                                              └──────────────────┘
</code></pre>
					<aside class="notes">In searchcode its a little more in depth because it actually changes the size of the bloom filters based on the size of the document its indexing.

What happens is when a document is indexed, it breaks it into unique trigrams, and then finds a bloom filter where it will be stored with a target bit density. If the document has a small amount of trigrams it ends up in a smaller bloom filter of say 256 bits, and if larger it goes into a larger one up to 4096.

When the full 64 documents have been added to a bucket then in the case of a 256 bit bloom filter another 256 uint64's are appended on the end.

Where shards represent a different bloom filter size, say 512 of 2048 bits, and buckets exist as a single uint64 slice in a shard. They are split out logiclly here to help understanding.
					</aside>
				</section>


				<section>
					<h2>Deterministic Keys</h2>
<pre><code style="font-size: 10px; line-height: 1em;">
// Trigrams given input splits according to trigram rules
// where we want to be as efficient as possible
func (ci *CaissonIndex) Trigrams(text string) []string {
    var runes = []rune(text)

    if len(runes) <= 2 {
        return []string{}
    }

    ngrams := make([]string, len(runes)-2)

    for i := 0; i < len(runes); i++ {
        if i+3 < len(runes)+1 {
            ngram := runes[i : i+3]
            ngrams[i] = string(ngram)
        }
    }

    return ngrams
}
</code></pre>
					<aside class="notes">Interesting fact, in profiling the single biggest bottleneck in indexing is the trigram code. Which I include here. If someone wants to profile and improve performance on it I would really appreciate it. It dominiates the indexing approach because the bit setting is close to free from a CPU point of view.</aside>
				</section>




				<section>
					<h2>Thank You!</h2>

					<p>Presentation located at <a href="https://boyter.org/static/golang-syd-25th-may/">https://boyter.org/static/golang-syd-25th-may/</a> or just go to boyter.org and I will link it up tomorrow.</p>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
