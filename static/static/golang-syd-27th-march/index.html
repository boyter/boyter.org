<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Golang-Syd 25th May 2023</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h1>searchcode.com's SQLite database is probably bigger than yours</h1>
				<code>-rw-r--r-- 1 searchcode searchcode 6.4T Feb 17 04:30 searchcode.db</code>
				<aside class="notes">So yeah... as it says the database is probably bigger than yours..</aside>
			</section>

			<!-- <section>
					<h2>Who are you?</h2>
					<p>
					"Officially" technical lead/principle at Kablamo but a "code monkey" at heart.</p>
					<p>I blog <a href="https://boyter.org/">boyter.org</a> I free software <a href="https://github/boyter/">github/boyter/</a> I run <a href="https://searchcode.com/">searchcode.com</a> also on the twitter <a href="https://twitter.com/boyter">@boyter</a> activitypub <a href="https://honk.boyter.org/boyter">@boyter@honk.boyter.org</a></p>
					<aside class="notes">Not going to bore you too much with who I am because you don't care.
					
					Aside, I was going to do a talk about how you can destroy the fediverse with a few lines of code... then thought better of it. If you want that  in the future go hassle Chewy or Katie.
					</aside>
				</section> -->


			<section>
				<img src="./img/searchcode.png" height="500px;" style="border: none;" />
				<code>-rw-r--r-- 1 searchcode searchcode 6.4T Feb 17 04:30 searchcode.db</code>
				<aside class="notes">I have talked about searchcode.com before, and the talks will continue until morale
					improves.

					Actually im not sure if it is the largest SQLite database in the world. I did find some random
					thread with someone talking about a 7TB one they worked on. Im fairly confident some CERN intern has
					a 100TB one working away somewhere they forgot about too.

					Its the largest one I know of thats public facing though.

					Seriously though its where I get to try all the crazy ideas I have at scale. Also I promise not to
					add any LLM or AI content to this, we are going old school baby.
				</aside>
			</section>

			<section>
				<section>
					<h2>History</h2>
					<img src="./img/history.png" height="500px;" style="border: none;" />
					<aside class="notes">The constant between everything till now was the use of MySQL as the storage
						layer. The reasons for using it initially was it was there, I knew how to work it and it would
						scale along with my needs fairly well. So what changed? If you look at my previous choices you
						will see there is in general a move to reducing the number of dependencies. The older and more
						crusty I get the more I appreciate having a single binary I can just deploy. Single binary
						deploys are very simple to reason about.
					</aside>
				</section>
			</section>




			<section>
				<h2>SQLite "database is locked"</h2>
				<pre><code style="font-size: 14px; line-height: 1em;">dbRead, _ := connectSqliteDb("dbname.db")
defer dbRead.Close()
dbRead.SetMaxOpenConns(runtime.NumCPU())

dbWrite, _ := connectSqliteDb("dbname.db")
defer dbWrite.Close()
dbWrite.SetMaxOpenConns(1)
</code></pre>

				<aside class="notes">
					So given our trigram terms we now need to index them. There are a few ways to do this. Lets walk
					through a few.

					A posting list is the slice of struct or int64 containing the document's have that term.

					So "set" is found inside documents 1,77 and 345

					A positional index is one that stores where the term was found in the document.

					So "set" as position 5 and 56 inside document 77

					This is really useful for phrase searches and ranking.
					In theory you can then use the index to reconstruct the document entirely. One catch with this is
					that your index becomes larger than the thing you are indexing.

					Done simply these are a bit of code you can had over to your cousin or most junior developer.

					Skip lists are something you end up needing to implement because when searching multiple terms you
					look for
					the intersection of multiple posting lists and it speeds things up and something you need to add to
					scale this approach.

					They are an interesting data structure worth looking up on wikipedia. When you start adding
					compression using ellias phano to reduce the size they quickly become complex, and it becomes easy
					to tank your performance.


				</aside>
			</section>

			<section>
				<h2>SQLite "database is locked"</h2>
				<pre><code style="font-size: 14px; line-height: 1em;">func connectSqliteDb(location, name string) (*sql.DB, error) {
	db, err := sql.Open("sqlite", fmt.Sprintf("%s.db?_busy_timeout=5000", path.Join(location, name)))
	if err != nil {
		return nil, err
	}

	_, err = db.Exec(`
pragma journal_mode = wal;
pragma synchronous = normal;
pragma temp_store = memory;
pragma mmap_size = 268435456;
pragma foreign_keys = on;
pragma busy_timeout = 5000;`)
	if err != nil {
		slog.Warn("pragma issue", "err", err.Error())
	}

	return db, nil
}
</code></pre>
				<small>Do lowercase SQL be a rebel!</small>

				<aside class="notes">
					PRAGMA journal_mode = wal;
					What it does: Switches the database to Write-Ahead Logging (WAL) mode instead of the default
					rollback journal mode.

					Effect:
					Transactions are written to a separate WAL file before being committed to the database, allowing
					concurrent reads and writes.

					Readers can access the database while a writer is active (unlike rollback mode, where writes
					lock
					the entire file).

					Writes are faster because they append to the WAL file rather than rewriting the main database
					file.

					Trade-off: Adds a WAL file (and potentially a -shm file for shared memory), increasing disk
					usage
					slightly. Checkpointing (merging WAL into the main DB) can lag under heavy write loads.

					PRAGMA synchronous = normal;
					What it does: Sets the synchronization level to Normal, balancing safety and speed.

					Effect:
					SQLite syncs data to disk at critical moments (e.g., after a transaction commits) but not as
					aggressively as FULL mode.

					Faster than FULL (which syncs after every write) but slower than OFF (no syncing).

					Protects against data loss in most crash scenarios, except rare OS or hardware failures.

					Trade-off: Slightly less durability than FULL (e.g., a power failure mid-transaction might
					corrupt
					the WAL), but much better performance than FULL.

					PRAGMA temp_store = memory;
					What it does: Forces SQLite to store temporary tables and indices in memory instead of on disk.

					Effect:
					Speeds up operations involving temporary data (e.g., complex JOINs, ORDER BY, or GROUP BY
					queries).

					Reduces disk I/O, which is especially helpful for large datasets or frequent temp table use.

					Trade-off: Increases memory usage. If your database workload generates lots of temp data and
					memory
					is tight, this could strain system resources.

					PRAGMA mmap_size = 268435456;
					What it does: Sets the memory-mapped I/O size to 268,435,456 bytes (256 MB).

					Effect:
					Maps the first 256 MB of the database file into memory, allowing SQLite to access it directly
					via
					memory pointers instead of traditional read/write calls.

					Boosts read performance for frequently accessed data within that 256 MB range.

					Trade-off: Uses more virtual memory, and benefits diminish if the database exceeds 256 MB (only
					the
					first chunk is mapped). Useless if the OS or hardware doesn't support memory mapping.


					PRAGMA foreign_keys = on;
					What it does: Enables foreign key constraints enforcement.

					Effect:
					Ensures referential integrity—e.g., you can’t delete a parent row if a child row references it,
					or
					insert a child row with an invalid foreign key.

					Makes the database behave more like traditional RDBMSes (e.g., PostgreSQL).

					Trade-off: Slightly slower writes due to extra checks, but it’s a safety net for data
					consistency.
					(Foreign key support is off by default in SQLite.)

					PRAGMA timeout here just specifies the timeout on the lock. You can also do it in most connection
					strings, I have repeated it here so you can see both.
				</aside>
			</section>


			<section>
				<h2>SQLite cross compiling</h2>
				<p>https://github.com/mattn/go-sqlite3</p>
				<code>GOOS=linux GOARCH=amd64 go build -ldflags="-s -w"</code>
				<p>https://modernc.org/sqlite</p>


				<aside class="notes">
					Possible to do this with the Zig toolchain these days... I am not familiar with this.


				</aside>
			</section>

			<section>
				<h2>Conversion</h2>


				<pre><code style="font-size: 14px; line-height: 1em;">increment := 10_000
for i := 0; i < totalRowCount; i += increment {
	between, _ := db.GetBetween(i, i+increment)
	
	tx, _ := sqliteDb.BeginTx(context.Background(), nil)
	defer tx.Rollback()

	withTx := db.WithTx(tx)

	for _, b := range between {
		_ = withTx.Insert(context.Background(), insertParams{
			...
		})
	}

	_ = tx.Commit()
}
				</code></pre>
				<aside class="notes">
					One problem I hit was I needed to convert close to a billion rows. Now, you can queue up the rows to
					insert but something thats faster and easier is to just batch them using transactions. This is a
					simple example of how you can do that. Note there is no error handling in the example above.

					For searchcode I was able to convert the whole database, so 10 tables at close to a billion rows
					using code like the above in about 48 hours, but I was limited because the database was a spinning
					rust HDD and I was writing to the same disk I was reading from.

					So appox 4 TB read and 6 TB written in 48 hours. Not bad for a single thread on a single spinning
					rust HDD.
				</aside>
			</section>


			<section>
				<h2>Compression Results</h2>
				<pre><code style="font-size: 14px; line-height: 1em;">$ compsize /mnt/data/searchcode.db
Processed 1 file, 16481352 regular extents (16481360 refs), 0 inline.
Type       Perc     Disk Usage   Uncompressed Referenced  
TOTAL       76%      4.8T         6.3T         6.3T       
none       100%      4.3T         4.3T         4.3T       
zstd        23%      470G         1.9T         1.9T
</code></pre>
				<aside class="notes">Not quite as good as I got in my tests, but still considerably smaller

					Note you need to use compsize to calculate this, as ls is unaware of the compression.</aside>
			</section>






			<section>
				<h2>Thank You!</h2>
				<p>Presentation located at <a
						href="https://boyter.org/static/golang-syd-25th-may/">https://boyter.org/static/golang-syd-25th-may/</a>
					or just go to boyter.org and I will link it up tomorrow.</p>
				<aside class="notes">
					Of course... probably nobody using searchcode probably cares that its running on a unique bloom
					filter trigram backed index with
					ideas borrowed from bing. But I know... and now you do too.

					Now this is meant to be interactive, so ill bring the code up and we can talk about whatever you
					like given time and get some questions out of the way.
				</aside>
			</section>

		</div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
		// More info about config & dependencies:
		// - https://github.com/hakimel/reveal.js#configuration
		// - https://github.com/hakimel/reveal.js#dependencies
		Reveal.initialize({
			dependencies: [
				{ src: 'plugin/markdown/marked.js' },
				{ src: 'plugin/markdown/markdown.js' },
				{ src: 'plugin/notes/notes.js', async: true },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } }
			]
		});
	</script>
</body>

</html>