<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Abusing Go, AWS Lambda and bloom filters to make a true Australian serverless search engine</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h1>Abusing Go, AWS Lambda and bloom filters to make a true Australian serverless search engine</h1>
					<aside class="notes">
Good morning Sydney!
Lovely to see everyone back for day two.
Hope you are all caffinated and comfortable.
As you can mostly see im talking about bloom filers and search. Sorry about the clickbait title, but you gotta stand out in the 
paper selection process somehow.
					</aside>
				</section>

				<section>
					<section>
						<h2>Who are you?</h2>
						<p>
						"Officially" technical lead/principle at Kablamo but a "code monkey" at heart.</p>
						<p>I blog <a href="https://boyter.org/">boyter.org</a> I free software <a href="https://github/boyter/">github/boyter/</a> I run <a href="https://searchcode.com/">searchcode.com</a> also on the twitter.com <a href="https://twitter.com/boyter">@boyter</a> activitypub <a href="https://honk.boyter.org/boyter">@boyter@honk.boyter.org</a></p>
						<aside class="notes">
So who am I? 
I am not going to bore you too much with who I am because you probably don't care. 
Im not famous, but you can find me at these places.
						</aside>
					</section>
					<section>
						<h2>https://boyter.org/</h2>
						<p>Everything is <a href="https://boyter.org/">here</a>, so feel free to go back to sleep</p>
						<img src="./img/halflisten.jpg" height="500px;" style="border: none;" />
						<aside class="notes">
For those who prefer to hang out on slack everything you are about to see is now available boyter.org
Don't worry too much about missing anything.
You can even skip ahead on the slides and head off for a coffee if you like. I won't judge you.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>My hobby; search engines</h2>
							<p>early termination, syntax highlighting, matching, snippet extraction, 
	rate limiting, index, bot detection, ranking, distributed algorithms, caching, tokenization,
	string searching, regular expressions, data structures, line detection, CPU cache lines, duplicate detection, 
	literal extraction, unicode, case insensitive matching etc...</p>
	<aside class="notes">
	Here are some of the things that go into any search engine.

	Every part you see is one of those problems you lightly scratch and discover
	people getting PhD's in. So it constantly keeps me interested and learning.
						</aside>
					</section>
					<section>
						<h2>searchcode.com</h2>
						<img src="./img/searchcode.gif" height="500px;" style="border: none;" />
						<aside class="notes">
So at the time I was building a new index for searchcode from scratch. 
No real reason beyond I find it interesting. I mentioned this to a work colleague and he 
asked why I didn't use AWS as generally for work everything lands there. 
I mentioned something to the effect that you needed a lot of persistent storage, 
or RAM to keep the index around which is prohibitively expensive. 

He mentioned perhaps using Lambda? And I responded its lack of persistance is a problem.
						</aside>
					</section>

					<section>
						<h2>Lambda/Serverless Weaknesses</h2>
						<ul>
							<li>Persistance</li>
							<li>Performance</li>
						</ul>
						<aside class="notes">
Lamba's or any other serverless function on cloud work well for certain problems. 
So long as you can rebuild state inside the lambda, because there is no guarantee it 
will still be running next time the lambda executes. The lack of persistance is an issue 
because modern search engines need to have some level of it. 
You either store the index in RAM, as most modern search engines do, or on disk.

At that point I trailed off. Something occurred to me.

Without persistance it makes lambda a non starter. But, there is a saying in computing.
						</aside>
					</section>

					<section>
						<blockquote>Never do at runtime what you can do at compile time.</blockquote>
						<aside class="notes">
I decided to see how far I can take that idea, by using AWS Lambda to build a search engine. 
How do we get get around the lack of persistance? By baking the index into the lambda themselves. 
In other words, generate code which contains the index and compile that into the lambda binary. 
Do it at compile time.
						</aside>
					</section>
				</section>



				<section>
					<section>
						<h2>Proving the theory</h2>
						<pre><code style="font-size: 14px; line-height: 1em;">package main

func main() {
	index := []string{
		"Memcached vs Redis - More Different Than You Would Expect",
		"You Don't Need a Library for File Walking in Go",
		// ... 99,997 more ...
		"Lessons Learnt Building for the Atlassian Marketplace",
	}

	for _, x := range index {
		strings.Contains(x, "searchterm")
	}
}
</code></pre>
						
						<aside class="notes">
So the first thing I considered was putting content directly into lambda’s, and then brute force 
searching across that content. Considering our guess of storing ~100,000 items in a lambda, a modern 
CPU brute force string searching in memory should return in a few hundred milliseconds. Modern CPU’s are very fast.

So I tried it. I created a Go file with 100,000 strings in a slice, and then wrote a simple loop 
to run over that performing a search.

Alas I underestimated how weak the CPU allotted to a lambda is, and searches took several seconds. 
Even increasing the RAM to improve the CPU allotment didn't really help. My fallback plan was to
 embed an index into the lambda, allowing for a quick scan over that index before looking at the content directly.
						</aside>
					</section>
					<section>
						<h2>This does not work...</h2>
						<img src="./img/lambdacpu.png" style="border: none;" />
						<aside class="notes">
Alas I underestimated how weak the CPU allotted to a lambda is, and searches took several seconds. 
Even increasing the RAM to improve the CPU allotment didn’t really help. 
My fallback plan was to embed an index into the lambda, allowing for a quick scan over that index 
before looking at the content directly.
						</aside>
					</section>
					<section>
						<h2>What is an index?</h2>
						<p>Structured list. Keys point at data so searches are faster.</p>
						<p>Given a term, return id's which contain it.</p>
						<aside class="notes">
So what is an index. The definition can be a little fuzzy, but I am defining it for me as a 
function that I pass in a term or terms and it returns a list of integers
which refer to documents that likely contain those terms, possibly ordered by relevance.
						</aside>
					</section>
					<section>
						<h2>Textbook 101 index</h2>

<pre><code style="font-size: 14px; line-height: 1em;">package main

func main() {
	index := map[string][]int{} 
	index["serverless"] = append(index["serverless"], 1337)
}
</code></pre>

						<aside class="notes">
So here is the textbook 101 example.
Given a term in this case "serverless" lets index it. 

The first index here is a non positional index. Its just a map of string to slice of integers.
Strings are the terms and integers the document ids.

The document id's slice are known as a posting list.
So "gopher" is found inside document 1337 here.

The next example is a positional index.
A positional index is one that stores where the term was found in the document. 

So "gopher" in document 1337 was found in positions 1, 2, 3 and 99.

Positional indexes are really useful for phrase searches and ranking.
One catch with this is that your index tends to becomes as large or larger than the thing you are indexing.
						</aside>
					</section>
					
					<section>
						<h2>Complexity</h2>
						<img src="./img/complex.png" style="border: none;" />
						<aside class="notes">
This introduces complexity.
This is clearly a lot more complex than what we started with. 
We need to build a CompressedSkipList.
						</aside>
					</section>
					<section>
						<h2>My attempt</h2>
						<p>Two turkeys taped together does not make an eagle.</p>
						<img src="./img/turkeys.jpg"  height="500px;" style="border: none;" />
						<aside class="notes">
This is what my attempted looked like.

So I did attempt to create a CompressedSkipList.

I implemented both the skip list and elias fano compression, and got two turkeys taped together.
Not the eagle I wanted.
						</aside>
					</section>
					
				</section>

				<section>
					<section>
						<h2>How about bloom filters?</h2>
						<p>A.K.A Bitsliced signatures</p>
						<aside class="notes">
There is a technique to search using bloom filters. However it helps if you know what one is.
						</aside>
					</section>
					<section>
						<h2>Bloom filter: Empty</h2>
						<p>16 boolean's in an array</p>
	<img src="./img/BloomFilter1.png" style="border: none;" />
						<aside class="notes">
So what is a bloom filter.
In short a space efficent probablistic data structure.

You add items, and can check if it was added. 

They never return false negatives, but they do occassionaly lie and report something being added when it was not.

So lets look at this example,

We have a 16 bit bloom filter. Its just a slice of booleans set by default to false, indicated by 0 here.
						</aside>
					</section>
					<section>
						<h2>Bloom filter: Add</h2>
						<p>Hash the term 3 times and set the bits</p>
	<img src="./img/BloomFilter2.png" style="border: none;" />
						<aside class="notes">
To add something to the filter we get a term, hash it multiple times using a integer returning hash like fnv, 
and use the resulting
outputs to map to bit positions inside our filter. We then set those positions to true.
						</aside>
					</section>
					<section>
						<h2>Bloom filter: Add second</h2>
						<p>3 more bits set</p>
	<img src="./img/BloomFilter3.png" style="border: none;" />
						<aside class="notes">
We add another term. Same process, hash 3 times and set the bits.
						</aside>
					</section>
					<section>
						<h2>Bloom filter: Add overlapping bits</h2>
						<p>"big" and "dog" share 2 bits</p>
	<img src="./img/BloomFilter4.png" style="border: none;" />
						<aside class="notes">
Another term added, where 2 of the bits overlap. This is an expected property of the filter
and one of the ways they are space efficient.
						</aside>
					</section>
					<section>
						<h2>Bloom filter: Hit</h2>
						<p>hash "big" and check bits</p>
	<img src="./img/BloomFilter5.png" style="border: none;" />
						<aside class="notes">
To check if the filter has something we do the same process. Hash the term as we did on insert,
then check the bit positions. They are all true so this indicates big was probably added to the filter.
Why probably? We will get to that in a moment.
						</aside>
					</section>
					<section>
						<h2>Bloom filter: Miss</h2>
						<p>one bit position is 0 so miss</p>
	<img src="./img/BloomFilter7.png" style="border: none;" />
						<aside class="notes">
Another check, but notice that the middle bit is false. This means we know that sydney was never added
to this filter.
						</aside>
					</section>
					<section>
						<h2>Bloom filter: False Positive</h2>
						<p>"big" and "yellow" supplied bits</p>
	<img src="./img/BloomFilter6.png" style="border: none;" />
						<aside class="notes">
Lastly we see an example of a false positive match. We hash and check the positions and they are all true.
But we never added this term, the bits were supplied by other terms.

Now while bloom filters do introduce false positives, remember we have to deal with them anyway 
since trigrams produce the same problem.

You will find that a lot of tweaking of bloom filters is to control the false positive rate.
						</aside>
					</section>

					<!-- <section>
						<h2>Go Bloom Filter</h2>

<pre><code style="font-size: 14px; line-height: 1em;">package main

import (
	"fmt"
	"hash/fnv"
)

func main() {
	bloom := make([]bool, 16)          // 16 bit bloom filter
	hash := func(term string) uint64 { // single hash function for bloom filter
		hsh := fnv.New64()
		_, _ = hsh.Write([]byte(term))
		return hsh.Sum64() % uint64(len(bloom))
	}

	bloom[hash("gopher")] = true // add to the filter
	bloom[hash("sydney")] = true

	for _, i := range bloom { // print out the filter
		if i == true {
			fmt.Print("1")
		} else {
			fmt.Print("0")
		}
	}

	if bloom[hash("sydney")] == true { fmt.Print("\nprobably added") }
	if bloom[hash("house")] == false { fmt.Print("\nwas not added") }
	if bloom[hash("boyter")] == true { fmt.Print("\nfalse positive! was never added!") }
}
</code></pre>

<pre><code style="font-size: 14px; line-height: 1em;">$ go run main.go 
0010000001000000
probably added
was not added
false positive! was never added!
</code></pre>

						<aside class="notes">
So here is a bloom filter implemented in go. The filter itself is 4 lines of code. A slice of booleans,
a function to hash and thats all you need. The output shows that terms were added, and a false positive.
						</aside>
					</section> -->

					<section>
						<h2>Bloom filter: search</h2>
					
						<p>Check bit positions 1 and 7. Document 4 matches.</p>
						<pre><code style="font-size: 14px; line-height: 1em;">for each bloomfilter
	for each bit
		check if bit location in filter is set
	if all matching bits are set
		record possible match</code></pre>

						<img src="./img/bloom_naieve_search.gif" height="400px" style="border: none;" />

						<aside class="notes">
So how to search over out bloom filter index? 

You just add more bloom filters.

This represents 4 documents each with their own 8 bit bloom filter. 

So to search we hash out search terms, which come to position 1 and 7. 
We loop over each filter, checking the bit positions at 1 and 7.
If any are false we know it cannot be a match.
If all are true we have a possible match. In this case document 4.
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Advantages</h2>
						<ul>
							<li>Compressed. Only using several bits per term!</li>
							<li>Just arrays of integers, easy to embed</li>
						</ul>
						<aside class="notes">
Bloom filters searches have a lot going for them. They are compressed by nature, using a few bits per term added.
They are also really simple to implement as you just saw, its only 5 lines of code.
Adding is simple, just add a new filter.
Editing is simple, just fiddle some values or replace the filter.
Searching is a really simple for loop.
You can extend them to counting bloom filters, or put structs for positions.

This technique lends itself pretty well to what I am attempting to do, because ultimately it’s just an 
array of 64 bit integers you scan across, making it trivial to write this out into a file which you then compile. Its also already compressed ensuring we can stay under our 50 MB limit while storing a lot of content. Lastly the actual code to do the search is a simple loop with some bitwise checks. Far easier to deal with than a skiplist, which would need to be written into code.
						</aside>
					</section>
					<section>
						<h2>Problems</h2>
						<p>No free lunch...</p>
						<p>8x overhead per bit because of how languages work...</p>
						<aside class="notes">
There are of course problems.

Firstly.

How much memory does 100 million bools take up? Almost 100 MB which if you calculate is about 8x what you expect.
						</aside>
					</section>
					<section>
						<h2>Problem 2</h2>
						<p>Generic RAM stick</p>
						<img src="./img/ram.jpg" height="500px" style="border: none;" />
						<aside class="notes">
Another problem is that is that this search is slow... This comes down to how fetching bits out of 
memory works.

When you probe a single bit on most modern sysems you actually pull back 512 bits from RAM. This is because a 
full cache line is read. So its a 512 times overhead just to test a single bit! 

As a result on average you end up walking ALL the memory for your filter, depending on which bits your probe.

This is one one of the reasons this as an approach fell out of favor in the 70's, because in practice
you do end up walking all the addressable memory.
						</aside>
					</section>
					<section>
						<h2>Illustration</h2>
						<img src="./img/2048_bloom_2.png"  style="border: none;" />
						<aside class="notes">
Here is a representation of the issue. We have a 2048 bit bloom filter, where each square is a bit.
We have hashed our terms to match 6 bit positions.

We used a good hash function so we get a decent distribution within those locations and now want to probe those
bits.
						</aside>
					</section>
					<section>
						<h2>Can we do better?</h2>
						<img src="./img/2048_bloom_3.png" style="border: none;" />
						<aside class="notes">
Because the bits are all within 512 bits of each other, we are likely to pull the entire filter across 
the CPU.

This is a big problem because accessing memory often isnt as fast as you expect. Modern CPU's can theoretically 
push more than 100 GB across the CPU per second.

In theory theory and practice are the same. In practice they arent.

In reality you are more likely to get 50 GB. So if your index is 100 GB in size
you are limited to 1 search every two seconds. 

Can we do better?
						</aside>
					</section>
				</section>

				
				

				<section>
					<section>
						<h2>Bitfunnel</h2>
						<p>Good enough for Dan Luu? Good enough for you.</p>
						<img src="./img/bitfunnel.png" style="border: none;" />
						<aside class="notes">
In 2017 at SIGIR this paper about bitfunnel was released, detailing how bing uses
bit signatures or bloom filters to power its fresh index.

It won best paper at SIGIR, which is probably the most prestigious IR conferences.

The thing that got my attention is that Dan Luu is a co-author. Anything he writes I pay attention to.
Hence my personal saying "Good enough for Dan Luu, Good enough for you."
						</aside>
					</section>
					<section>
							<h2>Fixes</h2>
							<p>Rotate the filter. Documents now on columns not rows.</p>
							<img src="./img/rotate.gif" height="500px" style="border: none;" />
							<aside class="notes">
In the 80's a smart person called Roberts noticed you could rotate the filter, 
assuming each filter has the same exact size.

So we do that by turning the rows into columns. So each row used to represent a document, 
but now each column does. Filled right to left.
		</aside>
					</section>

					<section>
						<p>Fetch row 1 and 7 same as previous example</p>
						<img src="./img/rotate3.png" height="500px" style="border: none;" />
						<aside class="notes">
With this done we only need to inspect the rows containing the bit positions of the query. 

So like our previous search we are checking bit postitions 1 and 7 which are now rows 1 and 7.
						</aside>
					</section>
					<section>
						<p>Logically & all rows</p>
						<img src="./img/rotate4.png" height="500px" style="border: none;" />
						<aside class="notes">
We then logically & them together and keep the result.

The nice thing about this is that a AND in the CPU is close to being a free operation from a performance 
point of view.
In fact the computation for this is so low it becomes all about the memory lookups.
						</aside>
					</section>
					<section>
						<p>Pos 1 is true, so document 4 matches</p>
						<img src="./img/rotate5.png" height="500px" style="border: none;" />
						<aside class="notes">
So in this particular case, we see a single bit is left on in the first position with 
corresponds to document 4.
This is because we filled right to left, based on our rotation.
						</aside>
					</section>
					<section>
						<h2>Results?</h2>
						<p>This reduces the amount of RAM we need to access by a huge factor for larger bloom filters.</p>
						<aside class="notes">
The result of this is it reduces memory access by a huge amount. Something like 200x.
						</aside>
					</section>

					<section>
						<h2>Result</h2>
						<p>16 bit bloom filter, with 32 documents added. Less wasted space.</p>
<pre><code style="font-size: 14px; line-height: 1em;">0000000000000000000000000000000010100011111111111111111111111101
0000000000000000000000000000000001110000000000010000100000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000100011111100000000000000000000
0000000000000000000000000000000000100000000000000000000000000000
0000000000000000000000000000000011000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000001000000000000001000000000000
0000000000000000000000000000000000111100000000000000000000000000
0000000000000000000000000000000000100001111100000001010101011110
0000000000000000000000000000000010000010000010001010101010100011
0000000000000000000000000000000001011000000000000000000000000000
0000000000000000000000000000000001101011111111111111111111111111
0000000000000000000000000000000000110000001000000001100000001000
0000000000000000000000000000000010100010000111111110101010100001
0000000000000000000000000000000001100011111100000000000000000000
</code></pre>
						<aside class="notes">
This is what it looks like in memory after adding 32 documents. We have a 16 bit bloom filter, 
with 16 int64's one after the other.
We have added 32 documents to it, so only the right most 32 bits have anything set. 

This ensures we are optimally using the space. Because we pack 64 documents into each 
int we end up using a single bit per location in the bloom filter. No 8x overhead!

It also becomes very fast to iterate this in code because its a simple for loop over a slice. 

It also means when we do our & operation we are now searching 64 documents for every operation, which is a huge speed up.
	</aside>
					</section>

					<section>
						<h2>Code Example</h2>
						<p>Example filter.</p>
<pre><code style="font-size: 14px; line-height: 1em;">
var bloomFilter = []uint64{1942, 1696, 1762, 496, 1776, 1954, 1970, 1536, 494, 134, 128, 1680, 0, 1536, 
2016, 1952, 2047, 296, 1600, 1536, 0, 64, 1664, 1985, 2046, 2032, 1760, 1536, 416, 1536, 360, 1568, 256, 
1920, 384, 0, 0, 1780, 1920, 1536, 256, 2032, 0, 1792, 1536, 1540, 1988, 0, 146, 1664, 2047, 288, 256, 1888, 
256, 2011, 128, 1778, 1904, 354, 0, 200, 1952, 496, 1920, 403, 1687, 384, 128, 1600, 1664, 0, 1600, 1990, 1760, 
1536, 256, 0, 0, 1664, 418, 1860, 1952, 256, 128, 162, 1736, 266, 64, 1922, 64, 1800, 0, 2003, 1920, 2016, 384, 
// a lot more follow...
1644, 1864, 1920, 64}

</code></pre>
						<aside class="notes">
This is what the filter looks like in code, where it literally is just a huge array of integers. I used 2048
integers per 64 documents, in my case to make things simple.
	</aside>
					</section>

					<section>
						<h2>Searching</h2>
						<p>The core loop.</p>
<pre><code style="font-size: 14px; line-height: 1em;">func Search(queryBits []uint64) []int {
	var results []int
	var res uint64

	for i := 0; i < len(bloomFilter); i += 2048 {
		res = bloomFilter[queryBits[0]+uint64(i)]

		for j := 1; j < len(queryBits); j++ {
			res = res & bloomFilter[queryBits[j]+uint64(i)]

			if res == 0 { // important! skip shard if nothing!
				break
			}
		}

		if res != 0 {
			for j := 0; j < 64; j++ {
				if res&(1<&lt;j) > 0 {
					results = append(results, 64*(i/2048)+j)
				}
			}
		}

	}

	return results
}
</code></pre>
						<aside class="notes">
The core search loop.

I find this algorithm beautifully simple.
				
The result of the above returns a list of interesting document id’s which can then be brute force checked
for the terms we believe are in there. We only believe because of the false positive property that bloom filters have. 
Bloom filters by default produce false positive results, but the above is fast enough to run in a 
few milliseconds cutting down on the total number of documents we need to inspect to a manageable level.

	</aside>
					</section>
					
					<section>
						<h2>Searching: Visually</h2>
						<p>Perform & between each row, and if we see 0 skip to next block</p>
						<img src="./img/bloomsearch.gif" height="500px" style="border: none;" /><br>
						<aside class="notes">
Visually the search looks a bit like this. Where it pulls back rows, 
logically anding them and moving to the 
next before jumping to the next block, or skipping ahead where it finds nothing.
						</aside>
					</section>

					<section>
						<h2>Time to search</h2>
<pre><code style="font-size: 14px; line-height: 1em;">
2021-09-13T14:33:34.114+10:00	Duration: 142.89 ms Billed Duration: 143 ms
2021-09-13T14:34:26.427+10:00	Duration: 6.44 ms Billed Duration: 7 ms 
2021-09-13T14:35:15.851+10:00	Duration: 3.40 ms Billed Duration: 4 ms 
2021-09-13T14:35:28.738+10:00	Duration: 1.10 ms Billed Duration: 2 ms 
2021-09-13T14:35:44.979+10:00	Duration: 6.11 ms Billed Duration: 7 ms 
2021-09-13T14:36:15.089+10:00	Duration: 70.31 ms Billed Duration: 71 ms 
</code></pre>

<aside class="notes">
Checking cloudwatch with the above implemented shows the following runtime’s for a variety of searches being 
run, on a lambda allocated with 1024 MB of RAM.

Keep in mind that the above times include ranking and snippet extraction as well and the result is ready to show to the user. 
Its not just the time for the core search.						
						
						</aside>
					</section>
				</section>
					





				<section>
					<h2>Conclusions</h2>
					<p>Go. I doubt I could have done it in another language.</p>
					<p>Bloomfilters + Trigrams works well. As far as I know this is globally unique. Nobody else I know uses this approach.</p>
					<p>A minimal version is available for you to play with <a href="https://github.com/boyter/indexer">https://github.com/boyter/indexer</a></p>
					<aside class="notes">
So conclusions.
I doubt I could have done this in another language. 
I like Go. I don't love it, it doesnt push the happy parts of my brain the way Python for example does.
But it just gets out of the way, and while I want to hurt myself every time I write another err nil check...
I realise I solved the problem... fairly quickly... the solution is solid and understandable and I just move on.
I guess that fits in with the boring that Go seems to aim for. Absolute success there.

The other is that Bloomfilters + Trigrams work really well. I actually asked chatgpt about this and it suggested
I shouldn't use them. 
Its also as far as I know unique approach with nobody having tried it before. Although nobody
in the search space really talk about what they are doing.

I have also uploaded a minimal version of everything for you to download and play around with.
					</aside>
				</section>

				<section>
					<p>Users probably don't care how searchcode's index works, but I know. Now you do too.</p>
					<img src="./img/gopher.png" height="500px" style="border: none;" /><br>
					<aside class="notes">


Of course... probably nobody using searchcode cares very much that its running on a unique bloom filter trigram
backed index with ideas borrowed from bing. 

But I know... and now you do too.

Thank you very much. Ill be at the Kablamo booth with the lovely stickers if you want to chat.
					</aside>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
